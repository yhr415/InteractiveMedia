/* autogenerated by Processing revision 1307 on 2025-12-16 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.io.*;
import javax.sound.midi.*;
import java.util.*;
import processing.sound.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class visualizer extends PApplet {

public void drawCircle(ArrayList<SynthTrack> tList) {
  // === [세팅] ===
  float cx = width / 2;       // 화면 중심 X
  float cy = height / 2;      // 화면 중심 Y
  float radius = height * 0.35f; // 원의 반지름 (화면 높이의 35%)
  
  // 트랙 수만큼 각도 쪼개기
  int count = tList.size();
  float angleStep = TWO_PI / count; 
  
  // === [그리기 반복] ===
  for (int i = 0; i < count; i++) {
    SynthTrack t = tList.get(i);
    
    // 각도 계산 (12시 방향인 -HALF_PI 부터 시작)
    float angle = -HALF_PI + (i * angleStep);
    
    // 극좌표계 변환 (각도와 거리로 X, Y 좌표 구하기)
    float x = cx + cos(angle) * radius;
    float y = cy + sin(angle) * radius;
    
    // --- [시각 효과 1: 중앙 연결선] ---
    // 소리가 날 때만 중앙이랑 연결되는 레이저 빔 쏘기
    if (t.power > 0.01f) {
      stroke(t.trackColor, t.power * 150); // 투명도 조절
      strokeWeight(1 + t.power * 2);
      line(cx, cy, x, y);
    }

    // --- [시각 효과 2: 트랙 원 (Orb)] ---
    // 비트가 터지면(power가 크면) 원도 커짐
    float orbSize = 15 + (t.power * 40); 
    
    noStroke();
    fill(t.trackColor, 200); // 기본 색상
    circle(x, y, orbSize);
    
    // --- [시각 효과 3: 하이라이트 (Sustain)] ---
    // 꾹 누르고 있는 음(Sustain)이 있으면 테두리 발광
    if (t.isNoteSus) {
      noFill();
      stroke(255, 200);
      strokeWeight(2);
      circle(x, y, orbSize + 10);
    }

    // --- [텍스트] ---
    // 원 바깥쪽에 트랙 번호 적기
    float labelDist = radius + 40; // 원보다 조금 더 멀리
    float lx = cx + cos(angle) * labelDist;
    float ly = cy + sin(angle) * labelDist;
    
    fill(150);
    textSize(10);
    textAlign(CENTER, CENTER);
    text(i, lx, ly);
  }
  
  // (선택사항) 화면 정중앙에 멋으로 하나 그려두기
  noStroke();
  fill(30);
  circle(cx, cy, 20);
}

// ★ 메인 신스 전용 비주얼라이저 (가로 파형 스타일)
public void drawMainVisualizer(SynthTrack t) {
  float cy = height / 2;
  
  // 1. 소리가 날 때 (Trigger) - 화면 전체 번쩍임(약하게)
  if (t.isNoteStart) {
    noStroke();
    fill(t.trackColor, 50);
    rect(0, 0, width, height);
  }
  
  // 2. 파형 그리기
  noFill();
  stroke(t.trackColor);
  strokeWeight(2 + t.power * 5); // 소리 크면 선이 굵어짐
  
  beginShape();
  for (int x = 0; x <= width; x += 10) {
    // 기본 y 위치 + 진동
    // power가 0이면 일직선, 1이면 미친듯이 요동침
    float noiseVal = noise(x * 0.01f, frameCount * 0.1f); // 자연스러운 움직임
    float amp = t.power * 150; // 진동 폭
    
    // sin파와 노이즈를 섞어서 전기 같은 느낌 줌
    float y = cy + sin(x * 0.05f + frameCount * 0.2f) * (amp * 0.2f) 
                 + (noiseVal - 0.5f) * amp * 2;
                 
    vertex(x, y);
  }
  endShape();
  
  // 3. 텍스트 라벨 (화면 상단 중앙)
  fill(255);
  textAlign(CENTER);
  text("MAIN SYNTH: " + t.name, width/2, cy - 100);
}

class Event {
  long tick;
  boolean on;
  int pitch;
  int vel;
  Event(long tick, boolean on, int pitch, int vel) {
    this.tick = tick;
    this.on = on;
    this.pitch = pitch;
    this.vel = vel;
  }
}

class SynthTrack {
  String name;
  int trackColor;
  double msPerTick; // 파일마다 해상도가 다를 수 있어서 개별 저장

  ArrayList<Event> events = new ArrayList<Event>();
  ArrayList<Integer> activePitches = new ArrayList<Integer>(); 

  int cursor = 0;
  
  // === [중요] 매핑을 위한 상태 변수들 ===
  boolean isNoteStart = false; // Trigger: 이번 프레임에 시작됐나?
  boolean isNoteSus = false;   // Sustain: 지금 소리가 나고 있나?
  
  // ★★★ 여기가 에러 원인! 이 변수가 없어서 에러가 난 겁니다 ★★★
  float power = 0; // 시각적 강도 (0.0 ~ 1.0)
  
  SynthTrack(String name, int c, double msPerTick) {
    this.name = name;
    this.trackColor = c;
    this.msPerTick = msPerTick;
  }

  public void reset() {
    activePitches.clear();
    cursor = 0;
    isNoteStart = false;
    isNoteSus = false;
    power = 0; // 리셋
  }

  public void sortByTick() {
    Collections.sort(events, new Comparator<Event>() {
      public int compare(Event a, Event b) {
        return Long.compare(a.tick, b.tick);
      }
    });
  }

  // 매 프레임 호출해서 상태 갱신
  public void update(long nowMs) {
    isNoteStart = false; 
    
    // ★ 잔상 효과 로직: 매 프레임 힘이 10%씩 빠짐 (부드러운 애니메이션)
    power = power * 0.9f; 
    
    while (cursor < events.size()) {
      Event e = events.get(cursor);
      long eventTimeMs = (long)Math.round(e.tick * msPerTick);

      if (eventTimeMs <= nowMs) {
        cursor++; // 이벤트 처리

        if (e.on) {
          if (!activePitches.contains(e.pitch)) {
            activePitches.add(e.pitch);
            isNoteStart = true; // ★ 시작 신호 발사!
            power = 1.0f;        // ★ 노트 시작될 때 파워 풀충전!
          }
        } else {
          if (activePitches.contains(e.pitch)) {
            activePitches.remove((Integer)e.pitch);
          }
        }
      } else {
        break; // 아직 처리할 시간이 안 됨
      }
    }
    
    // Sustain 상태 갱신
    if (activePitches.size() > 0) {
      isNoteSus = true;
      // 누르고 있는 동안은 파워가 0.5 밑으로 안 떨어지게 유지 (계속 빛나게)
      if(power < 0.5f) power = 0.5f; 
    } else {
      isNoteSus = false;
    }
  }
}





//=== Sound File ===
SoundFile musicFile;

// ====== 전역 설정 ======
float BPM = 132;          
double msPerTick = 0;     
long t0 = 0;              

// ====== 파일 로딩======
String mainMidiFile="lov3.mid";

// ====== 트랙 객체들 ======
ArrayList<SynthTrack> tracks = new ArrayList<SynthTrack>();
SynthTrack mainSynth; // mainsynth 01

public void setup() {
  /* size commented out by preprocessor */;
  //mp3 loading
  musicFile = new SoundFile(this, "lov3.mp3");
  //midi file의 track들을 쪼개서 신호로 변경
  loadSingleMidiAndSplitTracks(mainMidiFile);
  startPlayback();
}

public void draw() {
  background(20); // 배경 깔고
  long now = millis() - t0;
  
  // 1. [Main] 주인공 신스 처리 (특별 대우)
  if (mainSynth != null) {
    mainSynth.update(now); // 시간 업데이트 필수!
    drawMainVisualizer(mainSynth); // ★ 전용 비주얼라이저 호출
  }

  // 2. [Background] 나머지 조연들 처리 (원형 배치)
  // (트랙이 남아있을 때만 실행)
  if (tracks.size() > 0) {
    for (SynthTrack t : tracks) t.update(now);
    drawCircle(tracks);
  }
}

// ==========================================
//             유틸리티 함수들
// ==========================================

public void startPlayback() {
  t0 = millis();
  for (SynthTrack t : tracks) t.reset();
  if (musicFile != null) {
    musicFile.stop();
    musicFile.play();
  }
}

public void keyPressed() {
  if (key == 'r' || key == 'R') startPlayback();
}
public void loadSingleMidiAndSplitTracks(String fileName) {
  try {
    File f = new File(dataPath(fileName));
    // file loading debuging - fixed
    // if(!f.exists()) {
    //   println("[경고] 파일을 못 찾겠어!: " + fileName);
    //   return;
    // }
    
    Sequence seq = MidiSystem.getSequence(f);
    int ppq = seq.getResolution();
    double localMsPerTick = 60000.0f / (BPM * ppq);
    
    Track[] midiTracks = seq.getTracks();
    println("[체크] 원본 미디 파일의 총 트랙 수: " + midiTracks.length);

    int validTrackCount = 0; // 살아남은 트랙 수

    for (int i = 0; i < midiTracks.length; i++) {
      Track tr = midiTracks[i];
      
      // 1차 필터: 너무 텅 빈 트랙 패스
      if (tr.size() <= 1) continue; 

      String trackName = "Track " + i;
      int c = color(random(100, 255), random(100, 255), random(200, 255));
      SynthTrack newTrack = new SynthTrack(trackName, c, localMsPerTick);
      
      // 노트 추출
      fillNoteEvents(tr, newTrack.events);
      
      // ★★★ [중요] 2차 필터: "커팅" 들어갑니다 ★★★
      // 노트 개수가 10개 미만이면 "잡동사니" 취급하고 버림.
      // (만약 킥 드럼처럼 노트가 적은 악기라면 이 숫자를 5 정도로 낮춰)
      if (newTrack.events.size() < 10) {
         continue; // "넌 너무 가벼워! 탈락!"
      }

      // 합격한 놈들만 등록
      newTrack.sortByTick();
      tracks.add(newTrack);
      validTrackCount++;
      
      // 콘솔에 생존자 명단 출력 (누가 살아남았는지 확인해봐)
      println("[생존] 트랙 #" + i + " | 노트 수: " + newTrack.events.size());
    }

    if (tracks.size() > 0) {
      // 1. 리스트의 첫 번째 놈(0번)을 mainSynth로 임명
      mainSynth = tracks.get(0);
      
      // 2. 리스트에서는 삭제 (안 지우면 원형에도 또 나옴)
      tracks.remove(0);
      
      println("[분리 완료] 메인 신스 트랙이 분리되었습니다: " + mainSynth.name);
    }

    
    println("------------------------------------------------");
    println("[결과] 컷팅 완료! 총 " + validTrackCount + "개의 알짜배기 트랙만 남음.");
    
  } catch (Exception e) {
    e.printStackTrace();
  }
}

public void fillNoteEvents(Track midiTrack, ArrayList<Event> out) {
  for (int i = 0; i < midiTrack.size(); i++) {
    MidiEvent me = midiTrack.get(i);
    MidiMessage mm = me.getMessage();
    long tick = me.getTick();

    if (mm instanceof ShortMessage) {
      ShortMessage sm = (ShortMessage) mm;
      int cmd = sm.getCommand();
      int pitch = sm.getData1();
      int vel = sm.getData2();

      if (cmd == ShortMessage.NOTE_ON && vel > 0) {
        out.add(new Event(tick, true, pitch, vel));
      } else if (cmd == ShortMessage.NOTE_OFF || (cmd == ShortMessage.NOTE_ON && vel == 0)) {
        out.add(new Event(tick, false, pitch, vel));
      }
    }
  }
}


  public void settings() { size(1000, 600); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "visualizer" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
